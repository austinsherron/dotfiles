#!/usr/bin/env bash

source "${BASH_LIB}/core/str.sh"
source "${BASH_LIB}/utils/file.sh"
source "${BASH_LIB}/utils/input.sh"


## constants ###################################################################

export MAYBERN_REPO="${WORK_ROOT}/maybern"
export MAYBERN_BACKEND="${MAYBERN_REPO}/backend"
export MAYBERN_FRONTEND="${MAYBERN_REPO}/frontend"

## path updates ################################################################

export PATH="/opt/homebrew/opt/postgresql@17/bin:$PATH"
export PATH="/opt/homebrew/opt/libpq/bin:$PATH"

## important paths #############################################################

export WORK_ROOT="${WORKSPACE}/maybern"

## aliases #####################################################################

### rename

alias hf="helmfile"
alias kc="kubectl"
alias kctx="kubectx"
alias n="neonctl"
alias tf="terraform"
alias tg="terragrunt"

## functions ###################################################################

# gh

function pr() {
    local cmd="${1}"

    case $cmd in
        c|cr|create) gh pr create -a @me ;;
        m|mr|merge) just run-server ;;
        cl|close) gh pr close $(g branch --show-current) ;;
        l|ls|list) gh pr ls --author @me ;;
        n|num) gh pr view --json number | jq -r .number ;;
        v|view) gh pr view -w ;;
        *) ulogger error "Unknown command: $cmd" ; return 1 ;;
    esac
}

# just

function j() {
    if [[ ${#?} -gt 1 ]]; then
        just ${@}
        return $?
    fi

    local cmd="${1}"

    case $cmd in
         cc) just codegen client ;;
         cs) just codegen schema ;;
         gf) just generate-fixtures ;;
         rs) just run-server ;;
         rc) just run-celery ;;
          t) just pytest "${2:-}" ;;
          *) just ${@} ;;
    esac
}

# linear

function lin::get_issue_id() {
    linear issue list | tail -n +2 | fzf --ansi | awk '{print $2}'
}

function lin::start_issue() {
    local issue_id="$(str::lower $(lin::get_issue_id))"
    [[ $? -eq 130 ]] || [[ -z "$issue_id" ]] && return 0

    local branch_sfx="$(input::text "Branch suffix: ")"
    git new-branch "${issue_id}" "${branch_sfx}"
    [[ $? -gt 1 ]] && return 1

    linear issue update "${issue_id}" -s "started"
}

function lin() {
    local cmd="${1:-ls}"

    case $cmd in
        l|ls) linear issue list -s "unstarted" -s "backlog" -s "started" | grep -v "In QA" ;;
        s) lin::start_issue ;;
        *) linear ${@} ;;
    esac
}

# misc

function _find_test() {
    local rel_path="$(find "${MAYBERN_BACKEND}" -iname 'test_*.py' | sed "s/^$(path::escape ${MAYBERN_BACKEND}/)//" | fzf)"
    echo "${MAYBERN_BACKEND}/${rel_path}"
}

function run_test() {
    local test_path="$(_find_test)"
    local test="${1:+::$1}"

    if [[ -z "$test_path" ]]; then
        ulogger error "test file required"
        return 1
    fi

    just pytest "${test_path}${test}"
}

alias rt="run_test"

# slack

function add-slack-mentions() {
    local message="$1"
    local conf_file="$XDG_CONFIG_HOME/slack/users.conf"

    # build sed expression from slack.conf
    local sed_expr
    sed_expr=$(awk -F= '
        /^[^#[:space:]]+=U/ {
            printf "s/@%s/\\<@%s\\>/g;", $1, $2
        }
    ' "$conf_file")

    # apply the expression using sed
    echo "$message" | sed "$sed_expr"
}

function get-slack-channel-id() {
    local channel="${1#[@#]}"   # strip leading @ or # if present
    local id=""

    # look in channels.conf first (public/private channels)
    if [[ -f "$XDG_CONFIG_HOME/slack/channels.conf" ]]; then
        id=$(grep -s "^${channel}=" "$XDG_CONFIG_HOME/slack/channels.conf" | awk -F= '{print $2}')
    fi

    # if not found, look in users.conf (DMs -> user id)
    if [[ -z "$id" && -f "$XDG_CONFIG_HOME/slack/users.conf" ]]; then
        id=$(grep -s "^${channel}=" "$XDG_CONFIG_HOME/slack/users.conf" | awk -F= '{print $2}')
    fi

    echo "$id"
}

function send-slack-message() {
    local channel="${1}"
    local message="${2}"

    [[ "$channel" != \#* ]] && channel="$(get-slack-channel-id "$channel")"
    message="$(add-slack-mentions "$message")"

    local res=$(curl -s -X POST https://slack.com/api/chat.postMessage \
    -H "Authorization: Bearer $SLACK_USER_BOT_TOKEN" \
    -H 'Content-type: application/json' \
    --data "{
        \"channel\":\"${channel}\",
        \"text\":\"${message}\"
    }")

    echo "$res" | jq -r '.ok'
}
